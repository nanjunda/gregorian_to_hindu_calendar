<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precession: The Cosmic Top</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3 style="margin:0 0 5px 0; color:#4fc3f7;">The Great Wobble</h3>
        <small>Earth spins like a top.<br>The axis traces a circle every 26,000 years.</small>
    </div>
    <div id="controls">Drag to rotate â€¢ Watch the white axis pointer!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 100); // Lowered camera to see cone from below
        camera.lookAt(0, 30, 0); // Look higher up at the cone

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 20, 50);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x333333));

        // Function to create text sprites - SCALED DOWN DRASTICALLY
        function makeTextSprite(message, fontsize = 24, color = "rgba(255, 255, 255, 1.0)") {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = "Bold " + fontsize + "px Arial";
            const width = ctx.measureText(message).width;
            ctx.canvas.width = width + 20;
            ctx.canvas.height = fontsize + 20;

            ctx.font = "Bold " + fontsize + "px Arial";
            ctx.fillStyle = color;
            ctx.fillText(message, 10, fontsize);

            const texture = new THREE.CanvasTexture(ctx.canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            // SCALE REDUCED: Set to 0.05 (Half of previous 0.1)
            sprite.scale.set(width * 0.05, (fontsize + 20) * 0.05, 1);
            return sprite;
        }

        // Group to hold Earth + Axis (the "Top")
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        // Earth
        const earthGeo = new THREE.SphereGeometry(10, 32, 32);
        const earthMat = new THREE.MeshPhongMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            specular: 0x111111,
            shininess: 10,
            wireframe: true
        });
        const earth = new THREE.Mesh(earthGeo, earthMat);
        earthGroup.add(earth);

        // Axis Line (The Poker) - Longer
        const axisGeo = new THREE.CylinderGeometry(0.2, 0.2, 60, 8);
        const axisMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const axis = new THREE.Mesh(axisGeo, axisMat);
        axis.position.y = 20;
        earthGroup.add(axis);

        // VISUAL CONE STRUCTURE (Stationary)
        // A circle high above
        const topY = 45;
        const topRadius = 18; // Tan(23.5) * 45 approx

        const pathPoints = [];
        for (let i = 0; i <= 64; i++) {
            const th = (i / 64) * Math.PI * 2;
            pathPoints.push(new THREE.Vector3(Math.cos(th) * topRadius, topY, Math.sin(th) * topRadius));
        }
        const lineGeo = new THREE.BufferGeometry().setFromPoints(pathPoints);
        const lineMat = new THREE.LineDashedMaterial({ color: 0x4fc3f7, dashSize: 1, gapSize: 1 });
        const pathLine = new THREE.Line(lineGeo, lineMat);
        pathLine.computeLineDistances();
        scene.add(pathLine);

        // Cone Lines (connecting earth to circle)
        const coneMat = new THREE.LineBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.2 });
        for (let i = 0; i < 8; i++) {
            const th = (i / 8) * Math.PI * 2;
            const pts = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.cos(th) * topRadius, topY, Math.sin(th) * topRadius)
            ];
            const g = new THREE.BufferGeometry().setFromPoints(pts);
            scene.add(new THREE.Line(g, coneMat));
        }

        // Labels
        const stars = [
            { name: "Polaris", x: 0, z: -topRadius },
            { name: "Vega", x: 0, z: topRadius }
        ];

        stars.forEach(s => {
            // Star Dot
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            dot.position.set(s.x, topY, s.z);
            scene.add(dot);

            // Text Label
            const sprite = makeTextSprite(s.name, 48, "rgba(255, 255, 0, 1.0)");
            sprite.position.set(s.x, topY + 5, s.z);
            scene.add(sprite);
        });

        // Time Note - Positioned carefully
        const timeLabel = makeTextSprite("One Cycle = ~26,000 Years", 60, "rgba(79, 195, 247, 1.0)");
        timeLabel.position.set(25, topY, 0);
        scene.add(timeLabel);


        // Interaction
        let isDragging = false;
        let prevX = 0, prevY = 0;
        document.addEventListener('mousedown', e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = (e.clientX - prevX) * 0.01;
            const dy = (e.clientY - prevY) * 0.01;
            scene.rotation.y += dx;
            scene.rotation.x += dy;
            prevX = e.clientX; prevY = e.clientY;
        });

        // Touch
        document.addEventListener('touchstart', e => { isDragging = true; prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; });
        document.addEventListener('touchend', () => isDragging = false);
        document.addEventListener('touchmove', e => {
            if (!isDragging) return;
            const dx = (e.touches[0].clientX - prevX) * 0.01;
            const dy = (e.touches[0].clientY - prevY) * 0.01;
            scene.rotation.y += dx;
            scene.rotation.x += dy;
            prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
        });

        // Zoom/Scroll
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.1;
        });

        // Animation Loop
        // Set initial angle to Math.PI to align with Polaris (Start Position)
        let wobbleAngle = Math.PI;
        function animate() {
            requestAnimationFrame(animate);

            // 1. Earth Spins
            earth.rotation.y += 0.05;

            // 2. Axis Wobbles
            wobbleAngle += 0.005;
            // Radius/Height = 18/45 = 0.4. ~21 deg tilt.
            earthGroup.rotation.x = 0.4 * Math.cos(wobbleAngle);
            earthGroup.rotation.z = 0.4 * Math.sin(wobbleAngle);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>