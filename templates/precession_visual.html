<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precession: The Cosmic Top</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3 style="margin:0 0 5px 0; color:#4fc3f7;">The Great Wobble</h3>
        <small>Earth spins like a top.<br>The axis traces a circle every 26,000 years.</small>
    </div>
    <div id="controls">Drag to rotate â€¢ Watch the white axis pointer!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 80);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 20, 50);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x555555));

        // Function to create text sprites
        function makeTextSprite(message, fontsize = 24, color = "rgba(255, 255, 255, 1.0)") {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = "Bold " + fontsize + "px Arial";
            const width = ctx.measureText(message).width;
            ctx.canvas.width = width + 20;
            ctx.canvas.height = fontsize + 20;

            ctx.font = "Bold " + fontsize + "px Arial";
            ctx.fillStyle = color;
            ctx.fillText(message, 10, fontsize);

            const texture = new THREE.CanvasTexture(ctx.canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(width * 0.5, (fontsize + 20) * 0.5, 1);
            return sprite;
        }

        // Group to hold Earth + Axis (the "Top")
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        // Earth
        const earthGeo = new THREE.SphereGeometry(10, 32, 32);
        const earthMat = new THREE.MeshPhongMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            specular: 0x111111,
            shininess: 10,
            wireframe: true
        });
        const earth = new THREE.Mesh(earthGeo, earthMat);
        earthGroup.add(earth);

        // Axis Line (The Poker)
        const axisGeo = new THREE.CylinderGeometry(0.2, 0.2, 40, 8);
        const axisMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const axis = new THREE.Mesh(axisGeo, axisMat);
        axis.position.y = 10;
        earthGroup.add(axis);

        // The "Cone of Time" - DASHED CIRCLE PATH
        // We want a circle at y=28 (where the axis tip roughly ends)
        // Radius based on 23.5 degree tilt
        const coneHeight = 18; // From center? roughly
        // Let's assume the axis tip is at Y ~ 30 relative to center 
        // Earth R=10. Axis length 40, centered at Y=10. Top Y = 10 + 20 = 30.
        // Tilt 23.5 deg. Radius = 30 * sin(23.5) approx? 
        // More simply: we just want a visual ring that matches the wobble.

        const pathRadius = 11; // Visual fit
        const pathPoints = [];
        for (let i = 0; i <= 64; i++) {
            const th = (i / 64) * Math.PI * 2;
            pathPoints.push(new THREE.Vector3(Math.cos(th) * pathRadius, 28, Math.sin(th) * pathRadius));
        }
        const lineGeo = new THREE.BufferGeometry().setFromPoints(pathPoints);
        const lineMat = new THREE.LineDashedMaterial({ color: 0x4fc3f7, dashSize: 0.5, gapSize: 0.5 });
        const pathLine = new THREE.Line(lineGeo, lineMat);
        pathLine.computeLineDistances(); // Crucial for dashed line
        scene.add(pathLine);

        // Labels
        const stars = [
            { name: "Polaris", x: 0, z: -pathRadius },
            { name: "Vega", x: 0, z: pathRadius }
        ];

        stars.forEach(s => {
            // Star Dot
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            dot.position.set(s.x, 28, s.z);
            scene.add(dot);

            // Text Label
            const sprite = makeTextSprite(s.name, 32, "rgba(255, 255, 0, 1.0)");
            sprite.position.set(s.x, 32, s.z);
            scene.add(sprite);
        });

        // Time Note
        const timeLabel = makeTextSprite("One Cycle = ~26,000 Years", 40, "rgba(79, 195, 247, 1.0)");
        timeLabel.position.set(15, 28, 0); // Side
        scene.add(timeLabel);


        // Interaction
        let isDragging = false;
        let prevX = 0, prevY = 0;
        document.addEventListener('mousedown', e => { isDragging = true; prevX = e.clientX; prevY = e.clientY; });
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = (e.clientX - prevX) * 0.01;
            const dy = (e.clientY - prevY) * 0.01;
            scene.rotation.y += dx;
            scene.rotation.x += dy;
            prevX = e.clientX; prevY = e.clientY;
        });

        // Touch support
        document.addEventListener('touchstart', e => { isDragging = true; prevX = e.touches[0].clientX; prevY = e.touches[0].clientY; });
        document.addEventListener('touchend', () => isDragging = false);
        document.addEventListener('touchmove', e => {
            if (!isDragging) return;
            const dx = (e.touches[0].clientX - prevX) * 0.01;
            const dy = (e.touches[0].clientY - prevY) * 0.01;
            scene.rotation.y += dx;
            scene.rotation.x += dy;
            prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
        });

        // Zoom
        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.1;
        });


        // Animation Loop
        let wobbleAngle = 0;
        function animate() {
            requestAnimationFrame(animate);

            // 1. Earth Spins (Fast)
            earth.rotation.y += 0.05;

            // 2. Axis Wobbles (Slow)
            wobbleAngle += 0.005;
            // The tilt is 23.5 deg (approx 0.41 rad)
            // We rotate the GROUP to mimic precession
            // Note: The Path circle was drawn at Radius ~11, Y=28.
            // Using logic: Radius/Height = tan(tilt). 11/20 approx 0.5. atan(0.5) ~ 26 deg. Close enough visually.
            earthGroup.rotation.x = 0.41 * Math.cos(wobbleAngle);
            earthGroup.rotation.z = 0.41 * Math.sin(wobbleAngle);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>